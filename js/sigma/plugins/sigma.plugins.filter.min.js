/**
 * Sigma.js Filter Plugin - v1.0.0
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma not in scope.');

  // Add pkg utility if it doesn't exist
  sigma.utils = sigma.utils || {};
  sigma.utils.pkg = sigma.utils.pkg || function(pkg) {
    return pkg.split('.').reduce(function(context, current) {
      return (context[current] = context[current] || {});
    }, window);
  };

  // Initialize package:
  sigma.utils.pkg('sigma.plugins');

  sigma.plugins.filter = function(s) {
    var _s = s,
        _g = s.graph,
        _filters = {};

    this.undo = function(filterType) {
      if (filterType) {
        delete _filters[filterType];
      } else {
        _filters = {};
      }
      return this;
    };

    this.nodesBy = function(fn, filterType) {
      if (!filterType)
        throw new Error('filterType is required.');
      
      _filters[filterType] = {
        nodePredicate: fn
      };
      return this;
    };

    this.edgesBy = function(fn, filterType) {
      if (!filterType)
        throw new Error('filterType is required.');
      
      _filters[filterType] = {
        edgePredicate: fn
      };
      return this;
    };

    this.apply = function() {
      var n, e, nid, eid, filter, edge, srcNode, tgtNode;
      var g = _g;
      var nodes = g.nodes();
      var edges = g.edges();

      // Restore all nodes:
      for (nid in g.nodesIndex) {
        g.nodesIndex[nid].hidden = false;
      }

      // Restore all edges:
      for (eid in g.edgesIndex) {
        g.edgesIndex[eid].hidden = false;
      }

      // Apply filters to nodes:
      for (n in _filters) {
        filter = _filters[n];
        if (filter.nodePredicate) {
          for (nid in g.nodesIndex) {
            if (!filter.nodePredicate(g.nodesIndex[nid])) {
              g.nodesIndex[nid].hidden = true;
            }
          }
        }
      }

      // Apply filters to edges:
      for (e in _filters) {
        filter = _filters[e];
        if (filter.edgePredicate) {
          for (eid in g.edgesIndex) {
            if (!filter.edgePredicate(g.edgesIndex[eid])) {
              g.edgesIndex[eid].hidden = true;
            }
          }
        }
      }

      // Hide edges connected to hidden nodes:
      for (eid in g.edgesIndex) {
        edge = g.edgesIndex[eid];
        srcNode = g.nodesIndex[edge.source];
        tgtNode = g.nodesIndex[edge.target];
        if (srcNode.hidden || tgtNode.hidden) {
          edge.hidden = true;
        }
      }

      // Refresh visualization:
      _s.refresh();
      return this;
    };
  };
}).call(this); 